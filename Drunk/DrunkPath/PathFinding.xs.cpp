/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of PathFinding.xs. Do not edit this file, edit PathFinding.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "DrunkPath\\\\PathFinding.xs"
#include <stdlib.h>
#include <time.h>
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "algorithm.h"
typedef CalcDrunkPath_session * DrunkPath;

#line 20 "DrunkPath\\PathFinding.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 164 "DrunkPath\\PathFinding.c"

XS_EUPXS(XS_DrunkPath_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DrunkPath_create)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	DrunkPath	RETVAL;
#line 16 "DrunkPath\\\\PathFinding.xs"
		RETVAL = CalcDrunkPath_new ();

#line 177 "DrunkPath\\PathFinding.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DrunkPath",
	    (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DrunkPath__reset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DrunkPath__reset)
{
    dVAR; dXSARGS;
    if (items != 15)
       croak_xs_usage(cv,  "session, weight_map, avoidWalls, width, height, startx, starty, destx, desty, time_max, min_x, max_x, min_y, max_y, drunkness");
    {
	DrunkPath	session;
	SV *	weight_map = ST(1)
;
	SV *	avoidWalls = ST(2)
;
	SV *	width = ST(3)
;
	SV *	height = ST(4)
;
	SV *	startx = ST(5)
;
	SV *	starty = ST(6)
;
	SV *	destx = ST(7)
;
	SV *	desty = ST(8)
;
	SV *	time_max = ST(9)
;
	SV *	min_x = ST(10)
;
	SV *	max_x = ST(11)
;
	SV *	min_y = ST(12)
;
	SV *	max_y = ST(13)
;
	SV *	drunkness = ST(14)
;
#line 41 "DrunkPath\\\\PathFinding.xs"
		char *weight_map_data = NULL;

#line 229 "DrunkPath\\PathFinding.c"

	if (sv_derived_from(ST(0), "DrunkPath")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (DrunkPath) tmp;
	}
	else
		croak("session is not of type DrunkPath")
;
#line 45 "DrunkPath\\\\PathFinding.xs"
		/* If the object was already initiated, clean map memory */
		if (session->initialized) {
			free_currentMap_drunk(session);
			session->initialized = 0;
		}

		/* If the path has already been calculated on this object, clean openlist memory */
		if (session->run) {
			free_openList_drunk(session);
			session->run = 0;
		}

		/* Check for any missing arguments */
		if (!session || !weight_map || !avoidWalls || !width || !height || !startx || !starty || !destx || !desty || !time_max || !min_x || !max_x || !min_y || !max_y) {
			printf("[drunkpath reset error] missing argument\n");
			XSRETURN_NO;
		}

		/* Check for any bad arguments */
		if (SvROK(avoidWalls) || SvTYPE(avoidWalls) >= SVt_PVAV || !SvOK(avoidWalls)) {
			printf("[drunkpath reset error] bad avoidWalls argument\n");
			XSRETURN_NO;
		}

		if (SvROK(width) || SvTYPE(width) >= SVt_PVAV || !SvOK(width)) {
			printf("[drunkpath reset error] bad width argument\n");
			XSRETURN_NO;
		}

		if (SvROK(height) || SvTYPE(height) >= SVt_PVAV || !SvOK(height)) {
			printf("[drunkpath reset error] bad height argument\n");
			XSRETURN_NO;
		}

		if (SvROK(startx) || SvTYPE(startx) >= SVt_PVAV || !SvOK(startx)) {
			printf("[drunkpath reset error] bad startx argument\n");
			XSRETURN_NO;
		}

		if (SvROK(starty) || SvTYPE(starty) >= SVt_PVAV || !SvOK(starty)) {
			printf("[drunkpath reset error] bad starty argument\n");
			XSRETURN_NO;
		}

		if (SvROK(destx) || SvTYPE(destx) >= SVt_PVAV || !SvOK(destx)) {
			printf("[drunkpath reset error] bad destx argument\n");
			XSRETURN_NO;
		}

		if (SvROK(desty) || SvTYPE(desty) >= SVt_PVAV || !SvOK(desty)) {
			printf("[drunkpath reset error] bad desty argument\n");
			XSRETURN_NO;
		}

		if (SvROK(time_max) || SvTYPE(time_max) >= SVt_PVAV || !SvOK(time_max)) {
			printf("[drunkpath reset error] bad time_max argument\n");
			XSRETURN_NO;
		}

		if (!SvROK(weight_map) || !SvOK(weight_map)) {
			printf("[drunkpath reset error] bad weight_map argument\n");
			XSRETURN_NO;
		}

		if (SvROK(min_x) || SvTYPE(min_x) >= SVt_PVAV || !SvOK(min_x)) {
			printf("[drunkpath reset error] bad min_x argument\n");
			XSRETURN_NO;
		}

		if (SvROK(max_x) || SvTYPE(max_x) >= SVt_PVAV || !SvOK(max_x)) {
			printf("[drunkpath reset error] bad max_x argument\n");
			XSRETURN_NO;
		}

		if (SvROK(min_y) || SvTYPE(min_y) >= SVt_PVAV || !SvOK(min_y)) {
			printf("[drunkpath reset error] bad min_y argument\n");
			XSRETURN_NO;
		}

		if (SvROK(max_y) || SvTYPE(max_y) >= SVt_PVAV || !SvOK(max_y)) {
			printf("[drunkpath reset error] bad max_y argument\n");
			XSRETURN_NO;
		}

		if (SvROK(drunkness) || SvTYPE(drunkness) >= SVt_PVAV || !SvOK(drunkness)) {
			printf("[drunkpath reset error] bad drunkness argument\n");
			XSRETURN_NO;
		}

		/* Get the weight_map data */
		weight_map_data = (char *) SvPV_nolen (SvRV (weight_map));
		session->map_base_weight = weight_map_data;

		session->width = (int) SvUV (width);
		session->height = (int) SvUV (height);

		session->startX = (int) SvUV (startx);
		session->startY = (int) SvUV (starty);
		session->endX = (int) SvUV (destx);
		session->endY = (int) SvUV (desty);

		session->min_x = (int) SvUV (min_x);
		session->max_x = (int) SvUV (max_x);
		session->min_y = (int) SvUV (min_y);
		session->max_y = (int) SvUV (max_y);
		srand(time(0));
		session->drunkness = (int) SvUV (drunkness);

		// Min and max check
		if (session->min_x >= session->width || session->min_y >= session->height || session->min_x < 0 || session->min_y < 0) {
			printf("[drunkpath reset error] Minimum coordinates %d %d are out of the map (size: %d x %d).\n", session->min_x, session->min_y, session->width, session->height);
			XSRETURN_NO;
		}

		if (session->max_x >= session->width || session->max_y >= session->height || session->max_x < 0 || session->max_y < 0) {
			printf("[drunkpath reset error] Maximum coordinates %d %d are out of the map (size: %d x %d).\n", session->max_x, session->max_y, session->width, session->height);
			XSRETURN_NO;
		}

		// Start check
		if (session->startX >= session->width || session->startY >= session->height || session->startX < 0 || session->startY < 0) {
			printf("[drunkpath reset error] Start coordinate %d %d is out of the map (size: %d x %d).\n", session->startX, session->startY, session->width, session->height);
			XSRETURN_NO;
		}

		if (session->map_base_weight[((session->startY * session->width) + session->startX)] == -1) {
			printf("[drunkpath reset error] Start coordinate %d %d is not a walkable cell.\n", session->startX, session->startY);
			XSRETURN_NO;
		}

		if (session->startX > session->max_x || session->startY > session->max_y || session->startX < session->min_x || session->startY < session->min_y) {
			printf("[drunkpath reset error] Start coordinate %d %d is out of the minimum and maximum coordinates (size: %d .. %d x %d .. %d).\n", session->startX, session->startY, session->min_x, session->max_x, session->min_y, session->max_y);
			XSRETURN_NO;
		}

		// End check
		if (session->endX >= session->width   || session->endY >= session->height   || session->endX < 0   || session->endY < 0) {
			printf("[drunkpath reset error] End coordinate %d %d is out of the map (size: %d x %d).\n", session->endX, session->endY, session->width, session->height);
			XSRETURN_NO;
		}

		if (session->map_base_weight[((session->endY * session->width) + session->endX)] == -1) {
			printf("[drunkpath reset error] End coordinate %d %d is not a walkable cell.\n", session->endX, session->endY);
			XSRETURN_NO;
		}

		if (session->endX > session->max_x || session->endY > session->max_y || session->endX < session->min_x || session->endY < session->min_y) {
			printf("[drunkpath reset error] End coordinate %d %d is out of the minimum and maximum coordinates (size: %d .. %d x %d .. %d).\n", session->endX, session->endY, session->min_x, session->max_x, session->min_y, session->max_y);
			XSRETURN_NO;
		}

		session->avoidWalls = (unsigned short) SvUV (avoidWalls);
		session->time_max = (unsigned int) SvUV (time_max);

		CalcDrunkPath_init(session);
#line 394 "DrunkPath\\PathFinding.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_DrunkPath_run); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DrunkPath_run)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "session, solution_array");
    {
	DrunkPath	session;
	SV *	solution_array = ST(1)
;
#line 206 "DrunkPath\\\\PathFinding.xs"
		int status;
#line 412 "DrunkPath\\PathFinding.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DrunkPath")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (DrunkPath) tmp;
	}
	else
		croak("session is not of type DrunkPath")
;
#line 209 "DrunkPath\\\\PathFinding.xs"
		/* Check for any missing arguments */
		if (!session || !solution_array) {
			printf("[drunkpath run error] missing argument\n");
			XSRETURN_NO;
		}

		/* solution_array should be a reference to an array */
		if (!SvROK(solution_array)) {
			printf("[drunkpath run error] solution_array is not a reference\n");
			XSRETURN_NO;
		}

		if (SvTYPE(SvRV(solution_array)) != SVt_PVAV) {
			printf("[drunkpath run error] solution_array is not an array reference\n");
			XSRETURN_NO;
		}

		if (!SvOK(solution_array)) {
			printf("[drunkpath run error] solution_array is not defined\n");
			XSRETURN_NO;
		}

		status = CalcDrunkPath_pathStep (session);

		if (status < 0) {
			RETVAL = status;
		} else {
			AV *array;
			int size;

			size = session->solution_size;
 			array = (AV *) SvRV (solution_array);
			if (av_len (array) > size)
				av_clear (array);

			av_extend (array, session->solution_size);

			Node currentNode = session->currentMap[(session->endY * session->width) + session->endX];

			while (currentNode.x != session->startX || currentNode.y != session->startY)
			{
				HV * rh = (HV *)sv_2mortal((SV *)newHV());

				hv_store(rh, "x", 1, newSViv(currentNode.x), 0);

				hv_store(rh, "y", 1, newSViv(currentNode.y), 0);

				av_unshift(array, 1);

				av_store(array, 0, newRV((SV *)rh));

				currentNode = session->currentMap[currentNode.predecessor];
			}

			RETVAL = size;
		}
#line 480 "DrunkPath\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DrunkPath_runcount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DrunkPath_runcount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "session");
    {
	DrunkPath	session;
#line 272 "DrunkPath\\\\PathFinding.xs"
		int status;
#line 497 "DrunkPath\\PathFinding.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DrunkPath")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (DrunkPath) tmp;
	}
	else
		croak("session is not of type DrunkPath")
;
#line 275 "DrunkPath\\\\PathFinding.xs"
		status = CalcDrunkPath_pathStep (session);

		if (status < 0) {
			RETVAL = status;
		} else {
			RETVAL = (int) session->solution_size;
		}
#line 516 "DrunkPath\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DrunkPath_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DrunkPath_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "session");
    {
	DrunkPath	session;
#line 289 "DrunkPath\\\\PathFinding.xs"
		session = (DrunkPath) 0; /* shut up compiler warning */
#line 533 "DrunkPath\\PathFinding.c"

	if (sv_derived_from(ST(0), "DrunkPath")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (DrunkPath) tmp;
	}
	else
		croak("session is not of type DrunkPath")
;
#line 291 "DrunkPath\\\\PathFinding.xs"
		CalcDrunkPath_destroy (session);
#line 544 "DrunkPath\\PathFinding.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_DrunkPath); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_DrunkPath)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("DrunkPath::create", XS_DrunkPath_create, file, "");
        (void)newXSproto_portable("DrunkPath::_reset", XS_DrunkPath__reset, file, "$$$$$$$$$$$$$$$");
        (void)newXSproto_portable("DrunkPath::run", XS_DrunkPath_run, file, "$$");
        (void)newXSproto_portable("DrunkPath::runcount", XS_DrunkPath_runcount, file, "$");
        (void)newXSproto_portable("DrunkPath::DESTROY", XS_DrunkPath_DESTROY, file, "$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

